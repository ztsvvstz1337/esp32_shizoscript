
print("---UPDATE CHECK---");

all_files = [
	"boot.shs",
	"app_loader.shs",
	"web_portal.shs",
	"header_chunk.html",
	"section_start.html",
	"control_slider.html",
	"control_text.html",
	"control_checkbox.html",
	"control_color.html",
	"section_end.html",
	"footer_chunk.html",
];

remote_download(file_name, is_tmp)
{
	auto_update_path    = "https://raw.githubusercontent.com/ztsvvstz1337/esp32_shizoscript/main/bootscripts/esp32_p4/" + file_name;
	auto_update_local   = "/";
	if(is_tmp)
		auto_update_local += "tmp_";
	auto_update_local += file_name;

	print("Downloading: " + file_name);
	if(!download_git(auto_update_path, auto_update_local))
		error("Cannot download: " + auto_update_local);
		return 0;
	else 
		print("Successfully downloaded file.");
		return 1;
	return 0;
}

remote_download_safe(file_name, is_tmp)
{
	for(i = 0; i < 3; i++)
	{
		if(remote_download(file_name, is_tmp))
			return 1;
	}
	
	return 0;
}

cleanup_files()
{
	for(it :: all_files)
	{
		fileremove("/tmp_" + it);
		print("Cleaned: " + "/tmp_" + it);
	}
}

download_all()
{
	cleanup_files();
	
	//First try to download ALL files, if one fails, do not continue.
	for(it :: all_files)
	{
		if(!remote_download_safe(it, 1))
			print("Cannot download file! Aborting...");
			return 0;
	}
	
	//Now replace tmp file with real files...
	for(it :: all_files)
	{
		print("updating: " + it);
		tmp = fileread("/tmp_" + it);
		filewrite(it, tmp);
		print("updated.");
	}
	
	//Clean up once more
	cleanup_files();
	
	return 1;
}

check_updates()
{
	version_file_path = "https://raw.githubusercontent.com/ztsvvstz1337/esp32_shizoscript/main/bootscripts/esp32_p4/version.txt";
	version_file_local = "/version.txt";
	version_file_local2 = "/version_new.txt";
	download_git(version_file_path, version_file_local2);

	old_version = string(fileread(version_file_local));
	new_version = string(fileread(version_file_local2));
	
	if(!new_version:empty_str())
	{
		if(old_version == new_version)
		{
			print("Firmware is up to date (" + old_version + ")");
			return;
		}
		
		print("Updating version " + old_version + " to version " + new_version);
		
		if(download_all())		
			print("Update successful.");
			print("Rebooting...");
			filewrite(version_file_local, new_version);
			esp_restart();
		else
			print("Update failed, continuing...");
	}
	else
	{
		error("Cannot fetch new version!");
	}
}

//Check if we have internet for 5 seconds, if so, check for updates
print("Check for updates...");
if(has_internet(5000))
	check_updates();

print("---LOADING APP---");

//Simple counter to check how often we restarted within a 30 second window...
write_crash(status)
{
	filewrite("/crash_state.txt", string(status));
}
read_crash()
{
	return int(string(fileread("/crash_state.txt")));
}

web_portal_script = string(fileread("/web_portal.shs"));
if(!web_portal_script:empty_str())
	print("Loading webportal...");
	web_portal = loadmodule(web_portal_script, 0, 1);

local_script = string(fileread("/app.shs"));
print("Size: " + local_script:count());

main_app = 0;

if(!local_script:empty_str())
{
	last_state = read_crash();
	
	if(last_state == 10)
	{
		print("app scripted crashed too often, disabling it for now (reset to restart).");
		write_crash(0);
		return;
	}
	else(last_state > 0)
	{
		print("app crashed " + last_state + " times.");
	}
	
	write_crash(last_state+1);
		
	main_app = loadmodule(local_script, 0, 1);
	
	//After 30 seconds, consider the script "stable" and reset the crash counter...
	print("script evaluator(): init");
	sleep(1000 * 30);
	print("script evaluator(): script stable, resetting crash counter.");
	write_crash(0);
}

if(main_app == 0)
{
	print("No app loaded!");
}

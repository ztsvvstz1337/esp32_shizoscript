
set_auto_reload(1);

local_ver = int(os.file_as_string("bootscript/version.txt"));

//local_ver = int(os.file_as_string("bootscript/version.txt")) + 1;
//filewrite("bootscript/version.txt", string(local_ver));
//local_ver = string(local_ver);

local_firmware = "C:/Users/neu/Documents/Arduino/SKETCHES/ESP/esp_shizoscript_P4_Nano/build/esp32.esp32.esp32p4/esp_shizoscript_P4_Nano.ino.bin";
if(fileexists(local_firmware))
{
	lhash = filehash(local_firmware);
	ohash = filehash("firmware/firmware.esp32p4");
	print("Hashes: " + lhash + " " + ohash);
	if(lhash != ohash)
	{
		print("Updating firmware...");
		os.copy(local_firmware,"firmware/firmware.esp32p4");
		local_ver2 = int(os.file_as_string("firmware/version.txt")) + 1;
		filewrite("firmware/version.txt", string(local_ver2));
	}
}
local_firm_ver = os.file_as_string("firmware/version.txt");


net = shizonet_base("INSTALLER");

boot_files = files("bootscript");

for(#it :: boot_files)
	$it = it:substr(count("bootscript/"));

print(boot_files);

scr = ui.screen("APP FLASHER", 610,480);
wnd = ui.window(scr);
wnd := anchor_all = 0, layout = -1;
scroll = ui.vscroll(wnd);
scroll := anchor_all = 0;
item_cnt = ui.container(scroll);

items = 0;

get_apps()
{
	app_folders = folders("apps");
	
	apps = 0;
	
	for(i = 0; i < app_folders:count(); i++)
	{
		app_config = from_json_string(os.file_as_string(app_folders[i] + "/app_config.json"));
		print("app_config: ");
		print(app_config);
		
		if(app_config:count() == 0)
			print("invalid app!");
			print(app_folders[i]);
			continue;
		
		executables = filesext(app_folders[i], ".shs");
		data_content = files(app_folders[i] + "/data");

		apps[app_config.name] = [
			config=app_config, 
			app_paths = executables,
			data_paths = data_content,
			path=app_folders[i], 
			name=app_config.name,
		];
	}
	
	return apps;
}

create_entry(dev)
{
	print("DEV CONFIG:");
	print(dev.get("get_config"));
	print("DEV FILES:");
	print(dev.get("files"));
	print("DEV FIRMWARE:");
	print(dev.get("firmware_type"));
	
	if(items:has_key(dev.get_mac()))
	{
		print("device already registered.");
		free(items[dev.get_mac()]);
	}

	cnt = ui.widget(item_cnt);
	cnt := anchor_all = 3, anchor_top = -1, anchor_bottom = -1, fixed_height = 40, outline=0;
		
	items[dev.get_mac()] = cnt;
	
	name_label = ui.textbox(cnt, dev.get_name());
	name_label := anchor_all = 0, anchor_right = -1, fixed_width = 200, editable=1, font_size=20;
	name_label.callback = [dev, name_label]()
	{
		new_name = name_label.value;
		if(!new_name:starts("esp32"))
			new_name = "esp32_" + new_name;
		name_label.value = new_name;
		dev.send("set_config", [name=new_name]);
	}
	
	reboot_btn = ui.button(cnt, "REBOOT");
	reboot_btn := anchor_all = 0, anchor_right = -1, anchor_left = 200, fixed_width = 100;
	reboot_btn.callback = [dev]()
	{
		dev.send("reboot", 1);
	};
	
	reflash_btn = ui.button(cnt, "REFLASH");
	reflash_btn := anchor_all = 0, anchor_right = -1, anchor_left = 300, fixed_width = 100;
	reflash_btn.callback = [dev]()
	{
		print("Uploading...");
		for(it :: boot_files)
		{
			//print("Uploading...");
			print(dev.get("upload", [
				name=it,
				data=fileread("bootscript/" + it)
			]));
		}
		
		print("REBOOTING DEVICE...");
		
		sleep(500);
		
		dev.send("reboot", 1);
	};
	
	test_btn = ui.pushbutton(cnt, "TEST");
	test_btn := anchor_all = 0, anchor_right = -1, anchor_left = 400, fixed_width = 100;
	test_btn.callback = [dev, test_btn]()
	{
		print("Test device: " + test_btn.value);
		dev.send("test_device", test_btn.value);
	};
	
	app_select = ui.combobox(cnt);
	app_select := anchor_all = 0, anchor_right = -1, anchor_left = 500, fixed_width = 100, set_side("bottom");

	apps = get_apps();
	app_items = ["NO APP"];
	app_config = dev.get("get_app_config");
	active_app = -1;
	
	for(i = 0; i < apps:count(); i++)
	{
		app_items:push(apps:key(i));
		if(app_config.name == apps:key(i))
			active_app = i+1;
	}
	print(app_items);
	app_select.set_items(app_items);
	if(active_app >= 0)
		app_select.value = active_app;
	
	app_select.callback = [dev, app_select, apps]()
	{
		print("App select: " + app_select.value);
		id = app_select.value;
		dev.send("clear_app", 1);
		
		if(id > 0)
		{
			id--;
			app = apps[id];
			
			print("MODULES:");
			print(app.app_paths);
			
			for(exe :: app.app_paths)
			{
				print(dev.get("upload", [
					name="/app/" + os.file_name(exe) + ".shs",
					data=fileread(exe)
				]));
			}
			
			print("CONTENT:");
			print(app.data_paths);
			
			for(data :: app.data_paths)
			{
				print(dev.get("upload", [
					name="/data/" + os.file_name(data) + "." + os.file_ext(data),
					data=fileread(data)
				]));
			}
			
			dev.send("set_app_config", app.config);
		}
	};
}

print("---ON CONNECT---");
net.set_debug(1);
net.on_connect((dev)
{
	print(dev.get_name());
	if(dev.get_name():starts("esp32"))
	{
		print("GET FIRMWARE");
		cur_firm = dev.get("check_firm_version");
		
		for(cur_firm:empty_str())
		{
			print("Cannot get firmware, retrying...");
			sleep(2000);
			cur_firm = dev.get("check_firm_version");
			
			if(!dev.online())
				print("Device timed out!");
				return;
		}
		
		print("FIRM: " + cur_firm);
		if(dev.get("check_firm_version") != local_firm_ver)
		{
			print("Updating firmware...");
			bin = fileread("firmware/firmware.esp32p4");
			
			if(!bin)
				print("Firmware read error!");
			else
			{
			
				print(std.sha256(bin));
				
				print("start upload... " + bin:count());
				
				ota_res = dev.fetch("esp32_ota_enabled");
				print(ota_res);
				
				ota_res = dev.fetch("ESP32_OTA_START", bin:count());
				print(ota_res);
				
				chunk_start = 0;
				chunk_size = 1024 * 5;
				
				for(i = 0; i < bin:count(); i+=chunk_size)
				{
					sub_bin = bin:subset(i, chunk_size);
					print("SEND CHUNK: " + i + " SIZE: " + chunk_size);
					
					ota_res = dev.fetch("ESP32_OTA_CHUNK", sub_bin);
					
					print(ota_res);
					
					if(ota_res.success != 1)
						print("OTA CHUNK ERROR!");
						return;
					//sleep(2000);
				}
				
				print(dev.get("upload", [
					name="firm_version.txt",
					data=local_firm_ver
				]));
				
				ota_res = dev.fetch("ESP32_OTA_END", bin:count());
				
				return;
			}
			
		}

		if(dev.fetch("check_version") == local_ver)
			print("device is up to date.");
			create_entry(dev);
			return;
		
		print("Invalid version:");
		print(dev.fetch("check_version"));
		print(local_ver);
		
		print("Uploading...");
		for(it :: boot_files)
		{
			//print("Uploading...");
			print(dev.fetch("upload", [
				name=it,
				data=fileread("bootscript/" + it)
			]));
		}
		
		print("REBOOTING DEVICE...");
		
		sleep(2000);
		
		dev.send("reboot", 1);
	
		//dev.get("upload"
	}
});


all_files = [
	"boot.shs",
	"app_loader.shs",
	"web_portal.shs",
	"ui/header_chunk.html",
	"ui/section_start.html",
	"ui/control_slider.html",
	"ui/control_text.html",
	"ui/control_checkbox.html",
	"ui/control_color.html",
	"ui/section_end.html",
	"ui/footer_chunk.html",
	"ui/status_block.html",
];

global shizonet = shizonet_client();

print("---INIT NETAPI---");

shizonet.enable_shizonet(0); //Enabled at the end of this script

shizonet.on_get("check_version", (data, dev)
{
	version_file_local = "/version.txt";
	ver = string(fileread(version_file_local));
	if(ver:empty_str())
		ver = "0";
	return ver;
});
shizonet.on_get("check_firm_version", (data, dev)
{
	print("getting firmware version...");
	version_file_local = "/firm_version.txt";
	ver = string(fileread(version_file_local));
	if(ver:empty_str())
		ver = "0";
	print("ver: " + ver);
	return ver;
});
shizonet.on_get("upload", (data, dev)
{
	print("File upload: " + data.name + " (" + data.data:count() + ")");
	if(!data.name:empty_str())
		filewrite(data.name, data.data);
		return 1;
	return 0;
});
shizonet.on_get("download", (data, dev)
{
	if(!data:empty_str())
		print("File download: " + data);
		return fileread(data);
	return 0;
});
shizonet.on_get("files", (data, dev)
{
	return fs_list_files();
});
shizonet.on_get("firmware_type", (data, dev)
{
	return firmware_type();
});
shizonet.on_command("reboot", (data, dev)
{
	print("REBOOT");
	esp_fastrestart();
});
shizonet.on_command("set_config", (data, dev)
{
	if(data:is_json())
	{
		for(i = 0; i < data:count(); i++)
		{
			default_config[data:key(i)] = data[i];
			print("Set config option " + data:key(i) + " to " + data[i]);
			
			if(data:key(i) == "name")
				shizonet.set_name(data[i]);
		}
		
		save_config();
	}
});
shizonet.on_get("get_config", (data, dev)
{
	return default_config;
});

print("---UPDATE CHECK---");

remote_download(file_name, is_tmp)
{
	auto_update_path    = "https://raw.githubusercontent.com/ztsvvstz1337/esp32_shizoscript/main/bootscript/" + file_name;
	auto_update_local   = "/";
	auto_update_local += file_name;

	if(is_tmp)
		auto_update_local += ".tmp";

	print("Downloading: " + file_name);
	if(!download_git(auto_update_path, auto_update_local))
		error("Cannot download: " + auto_update_local);
		return 0;
	else 
		print("Successfully downloaded file.");
		return 1;
	return 0;
}

remote_download_safe(file_name, is_tmp)
{
	for(i = 0; i < 3; i++)
	{
		if(remote_download(file_name, is_tmp))
			return 1;
	}
	
	return 0;
}

cleanup_files()
{
	for(it :: all_files)
	{
		fileremove(it + ".tmp");
		print("Cleaned: " + it + ".tmp");
	}
}

download_all()
{
	cleanup_files();
	
	//First try to download ALL files, if one fails, do not continue.
	for(it :: all_files)
	{
		if(!remote_download_safe(it, 1))
			print("Cannot download file! Aborting...");
			return 0;
	}
	
	//Now replace tmp file with real files...
	for(it :: all_files)
	{
		print("updating: " + it);
		tmp = fileread(it + ".tmp");
		filewrite(it, tmp);
		print("updated.");
	}
	
	//Clean up once more
	cleanup_files();
	
	return 1;
}

check_updates()
{
	print("Checking firmware...");
	//First, update firmware
	content_path = "https://raw.githubusercontent.com/ztsvvstz1337/esp32_shizoscript/main/firmware/";
	version_file_path = content_path + "version.txt";
	version_file_local = "/firm_version.txt";
	version_file_local2 = "/firm_version_new.txt";
	download_git(version_file_path, version_file_local2);
	old_version = string(fileread(version_file_local));
	new_version = string(fileread(version_file_local2));
	
	if(!new_version:empty_str())
	{
		if(int(old_version) < int(new_version))
		{
			print("Updating firmware...");
			if(download_ota(content_path + "firmware." + firmware_type()))
			{
				print("Update successful.");
				print("Rebooting...");
				filewrite(version_file_local, new_version);
				esp_fastrestart();
			}
		}
		else
			print("Firmware is up to date (" + old_version + ")");
	}
	
	print("Checking bootscripts...");
	//Now update bootscripts...
	version_file_path = "https://raw.githubusercontent.com/ztsvvstz1337/esp32_shizoscript/main/bootscript/version.txt";
	version_file_local = "/version.txt";
	version_file_local2 = "/version_new.txt";
	download_git(version_file_path, version_file_local2);
	old_version = string(fileread(version_file_local));
	new_version = string(fileread(version_file_local2));
	
	if(!new_version:empty_str())
	{
		if(int(old_version) < int(new_version))
		{			
			print("Updating bootscript version " + old_version + " to version " + new_version);
			
			if(download_all())		
				print("Update successful.");
				print("Rebooting...");
				filewrite(version_file_local, new_version);
				esp_fastrestart();
			else
				print("Update failed, continuing...");
		}
		else
			print("Bootscripts up to date (" + old_version + ")");
	}
	else
	{
		error("Cannot fetch new version!");
	}
}

//Check if we have internet for 5 seconds, if so, check for updates
print("Check for updates...");
if(has_internet(5000))
	check_updates();

print("---LOADING APP---");

//Simple counter to check how often we restarted within a 30 second window...
write_crash(status)
{
	filewrite("/crash_state.txt", string(status));
}
read_crash()
{
	return int(string(fileread("/crash_state.txt")));
}

web_portal_script = string(fileread("/web_portal.shs"));
if(!web_portal_script:empty_str())
	print("Loading webportal...");
	web_portal = loadmodule(web_portal_script, 0, 1);
else
	print("No webportal found!");

app_config = from_json_string(fileread("app_config.json"));
print("APP CONFIG:");
print(app_config);

shizonet.on_command("set_app_config", (data, dev)
{
	if(data:is_json())
	{
		filewrite("app_config.json", to_json_string(data));
		print("APP CONFIG:");
		print(data);
	}
});

shizonet.on_get("get_app_config", (data, dev)
{
	return app_config;
});

shizonet.on_command("clear_app", (data, dev)
{
	fl = fs_list_files();
	
	for(it :: fl)
	{
		if(it:starts("/app/"))
		{
			print("Removing: " + it);
			fileremove(it);
		}
	}
	filewrite("app_config.json", "");
	print("Cleared app.");
});

shizonet.enable_shizonet(1);

app_files = fs_list_files();
app_sources = 0;

for(app_src :: app_files)
{
	if(app_src:starts("/app/") && app_src:find(".shs") >= 0)
	{
		app_sources:push(app_src);
	}
}

loaded_apps = 0;

if(app_sources:count() > 0)
{
	last_state = read_crash();
	
	if(last_state == 5)
	{
		print("app scripted crashed too often, disabling it for now (reset to restart).");
		write_crash(0);
		return;
	}
	else(last_state > 0)
	{
		print("app crashed " + last_state + " times.");
	}
	
	write_crash(last_state+1);
		
	main_entries = 0;
		
	for(app_src :: app_sources)
	{
		print("loading: " + app_src);
		main_app = loadmodule(string(fileread(app_src)), 0, 1);
		loaded_apps:push(main_app);
		if(main_app.has("main"))
			main_entries:push(main_app.get("main"));
	}
		
		
	print("---MAIN ENTRIES---");
	for(main_entry :: main_entries)
	{
		main_entry();
	}
	
	//After 30 seconds, consider the script "stable" and reset the crash counter...
	print("script evaluator(): init");
	sleep(1000 * 30);
	print("script evaluator(): script stable, resetting crash counter.");
	write_crash(0);
}
else
{
	print("No app loaded!");
}


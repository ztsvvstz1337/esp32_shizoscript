
global create_gpt_oss = 0;

global driver = 0;

global led_segments = from_json_string(string(fileread("/static/segments.json")));
global led_segments_groups = 0;

global dmx_fixtures = from_json_string(string(fileread("/static/dmx_fixtures.json")));

global group_anims = from_json_string(string(fileread("/static/effects.json")));


//First ever init
if(led_segments:count() == 0)
{
	//led_segments = [
	//	[name="Output 1", pin=21, segments=[[name="Segment 1", width=10,count=1,color="#000000",brightness=255,enabled=1,group="Default"]]]
	//];
}

get_color(str)
{
	r = 0;
	g = 0;
	b = 0;
	if(str[0] == "#")
	{
		r = hex_to_char(str:substr(1,2)) / 255.0;
		g = hex_to_char(str:substr(3,2)) / 255.0;
		b = hex_to_char(str:substr(5,2)) / 255.0;
	}
	return [r=r,g=g,b=b];
}

has_solo_segments = 0;
get_leds_out_count()
{
	max_outs = 0;
	has_solo_segments = 0;
	for(#it :: led_segments)
	{
		seg_count = 0;
		for(#seg :: it.segments)
		{
			seg_count += seg.width * max(1,seg.count);
			if(seg.testout)
				has_solo_segments = 1;
		}
		if(seg_count > max_outs)
			max_outs = seg_count;
	}
	
	return int(max_outs);
}

init_driver()
{
	pins = 0;
	max_output = get_leds_out_count();
	
	for(it :: led_segments)
	{
		pins:push(it.pin);	
	}
	
	print("init driver with pins:");
	print(pins);
	print("And max led out: " + max_output);
	print("LED Channels: " + 3);
	
	if(max_output == 0)
		return;
	if(pins:count() == 0)
		return;
	
	if(driver == 0)
	{
		driver = led_driver(pins, max_output, 3);
		driver.enable_artnet();
		driver.show();
	}
	else
	{
		driver.blackout();
		driver.show_now();
		driver.init_leds(pins, max_output, 3);
	}
}

// # MAIN PAGE
webui.on_main_page = ()
{
	page = webui.add_section("Animation & Control");
	page += webui.add_html("/data/animation_editor.html");
	return page;
};

update_anims()
{
	for(i = 0; i < group_anims:count(); i++)
	{
		driver.set_effect(group_anims:key(i), group_anims[i].effect);
		
		col1 = get_color(group_anims[i].color1);
		col2 = get_color(group_anims[i].color2);
		
		driver.set_effect_color1(group_anims:key(i), col1.r, col1.b, col1.g);
		driver.set_effect_color2(group_anims:key(i), col2.r, col2.b, col2.g);
		
		driver.set_effect_intensity(group_anims:key(i), group_anims[i].intensity);
		driver.set_effect_speed(group_anims:key(i), group_anims[i].speed);
		driver.set_effect_ctrl1(group_anims:key(i), group_anims[i].ctrl1);	
		driver.set_effect_ctrl2(group_anims:key(i), group_anims[i].ctrl2);	
		driver.set_effect_ctrl3(group_anims:key(i), group_anims[i].ctrl3);			
	}
	
	filewrite("/static/effects.json", to_json_string(group_anims));
}

webui.add_json("/effects_get", (post_data)
{	
	return [effects=driver.get_effects(),
			palettes = [
				[name="Warm",id="builtin_warm"],
				[name="Cool",id="builtin_cool"],
				[name="Party",id="builtin_party"],
			],
			settings = group_anims,
		];
});

webui.add_post("/animations_update", (post_data)
{	
	group_anims = from_json_string(post_data.plain);

	if(group_anims:count() == 0)
		return;

	filewrite("/static/animations.json", to_json_string(group_anims));

	update_anims();
});

// # SEGMENTS

last_num_outputs = -1;
last_max_leds = -1;

update_segments()
{
	new_max_leds = get_leds_out_count();
	
	if(last_num_outputs == -1)
		last_num_outputs=led_segments:count();
	if(last_max_leds == -1)
		last_max_leds = new_max_leds;
	
	if(last_max_leds != new_max_leds || last_num_outputs != led_segments:count())
	{
		//Re-init driver...
		print("---REINIT DRIVER---");
		init_driver();
	}
	
	last_max_leds = new_max_leds;
	last_num_outputs = led_segments:count();
	
	driver.set_target("SMOOTHBUFFER");
	
	led_segments_groups = 0;
	
	
	output_id = 0;
	for(#it :: led_segments)
	{
		segment_id = 0;
		current_index = 0;
		for(#seg :: it.segments)
		{
			led_segments_groups[seg.group]:push($seg);
			
			ledcount = int(seg.width * max(1,seg.height));
			
			for(i = 0; i < seg.count; i++)
			{			
				//Sort after group and total LED count (to avoid double rendering same segments)
				led_segments_groups[seg.group][string(ledcount)]:push([output=output_id, index=current_index+ledcount*i, count=ledcount]);
			}
			
			brightness = seg.brightness / 255.0;
			col = get_color(seg.color);
			
			if(has_solo_segments && !seg.testout)
				brightness = 0;
			
			driver.set_pixels(output_id, current_index, seg.width * max(1,seg.height) * max(1,seg.count), col.r*brightness*255.0, col.g*brightness*255.0, col.b*brightness*255.0);
			current_index += seg.width * max(1,seg.height) * max(1,seg.count);
			segment_id++;
		}
		
		output_id++;
	}
	
	driver.set_effect_groups(led_segments_groups);
	
}

update_fixtures()
{
	output_id = 0;
	for(#it :: led_segments)
	{
		
	}
}

webui.add_site("/segments", ()
{	
	page = webui.add_html("/data/segment_editor.html");
	
	return page;
});

webui.add_post("/segments_update", (post_data)
{	
	segments_json = from_json_string(post_data.plain);

	if(segments_json:count() == 0)
		return;

	filewrite("/static/segments.json", to_json_string(segments_json.led_outputs));
	filewrite("/static/dmx_fixtures.json", to_json_string(segments_json.dmx_outputs));
	
	led_segments = segments_json.led_outputs;
	dmx_fixtures = segments_json.dmx_outputs;
	
	update_segments();
});

webui.add_json("/segments_get", (post_data)
{	
	return [led_outputs=led_segments, dmx_outputs=dmx_fixtures];
});

webui.add_header("LEDS", "/segments");
webui.add_header("DMX", "/segments");

init_driver();
update_segments();
update_anims();

main()
{
	//print("hello from main!");
	
	print("---STARTING LED DRIVER---");
	
	return;

	print("---TESTING GPT OSS---");
	
	llm = create_gpt_oss();
	
	llm.history.on_analysis = (stepid, txt)
	{
		print(txt);
	};
	
	llm.history.on_answer = (stepid, txt)
	{
		print(txt);
	};
	
	print(llm.text("Who are you?"));
	print("FINISHED.");
}
